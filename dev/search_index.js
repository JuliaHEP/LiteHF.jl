var documenterSearchIndex = {"docs":
[{"location":"#LiteHF.jl","page":"LiteHF.jl","title":"LiteHF.jl","text":"","category":"section"},{"location":"","page":"LiteHF.jl","title":"LiteHF.jl","text":"Documentation for LiteHF.jl","category":"page"},{"location":"","page":"LiteHF.jl","title":"LiteHF.jl","text":"Modules = [LiteHF]\nOrder   = [:type, :function]","category":"page"},{"location":"#LiteHF.ExpCounts","page":"LiteHF.jl","title":"LiteHF.ExpCounts","text":"struct ExpCounts{T, M} #M is a long Tuple for unrolling purpose.\n    nominal::T\n    modifier_names::Vector{Symbol}\n    modifiers::M\nend\n\nA callable struct that returns the expected count given modifier nuisance parameter values. The # of parameters passed must equal to length of modifiers. See _expkernel\n\n\n\n\n\n","category":"type"},{"location":"#LiteHF.FlatPrior","page":"LiteHF.jl","title":"LiteHF.FlatPrior","text":"Pseudo flat prior in the sense that `logpdf()` always evaluates to zero,\nbut `rand()`, `minimum()`, and `maximum()` behaves like `Uniform(a, b)`.\n\n\n\n\n\n","category":"type"},{"location":"#LiteHF.Histosys","page":"LiteHF.jl","title":"LiteHF.Histosys","text":"Histosys is defined by two vectors represending bin counts in hi_data and lo_data\n\n\n\n\n\n","category":"type"},{"location":"#LiteHF.InterpCode0","page":"LiteHF.jl","title":"LiteHF.InterpCode0","text":"InterpCode0{T}\n\nCallable struct for interpolation for additive modifier. Code0 is the two-piece linear interpolation.\n\n\n\n\n\n","category":"type"},{"location":"#LiteHF.InterpCode1","page":"LiteHF.jl","title":"LiteHF.InterpCode1","text":"InterpCode1{T}\n\nCallable struct for interpolation for multiplicative modifier. Code1 is the exponential interpolation.\n\n\n\n\n\n","category":"type"},{"location":"#LiteHF.InterpCode4","page":"LiteHF.jl","title":"LiteHF.InterpCode4","text":"InterpCode4{T}\n\nCallable struct for interpolation for additive modifier. Code4 is the exponential + 6-order polynomial interpolation.\n\n\n\n\n\n","category":"type"},{"location":"#LiteHF.Lumi","page":"LiteHF.jl","title":"LiteHF.Lumi","text":"Luminosity doesn't need interpolation, σ is provided at modifier construction time. In pyhf JSON, this  information lives in the \"Measurement\" section, usually near the end of the JSON file.\n\n\n\n\n\n","category":"type"},{"location":"#LiteHF.Normfactor","page":"LiteHF.jl","title":"LiteHF.Normfactor","text":"Normfactor is unconstrained, so interp is just identity.\n\n\n\n\n\n","category":"type"},{"location":"#LiteHF.Normsys-Tuple{Number, Number}","page":"LiteHF.jl","title":"LiteHF.Normsys","text":"Normsys is defined by two multiplicative scalars\n\n\n\n\n\n","category":"method"},{"location":"#LiteHF.PyHFModel","page":"LiteHF.jl","title":"LiteHF.PyHFModel","text":"struct PyHFModel\n    expected\n    priors\n    prior_names\n    prior_inits::Vector{Float64}\n    LogLikelihood\nend\n\nStruct for holding result from build_pyhf.\n\n\n\n\n\n","category":"type"},{"location":"#LiteHF.RelaxedPoisson","page":"LiteHF.jl","title":"LiteHF.RelaxedPoisson","text":"RelaxedPoisson\n\nPoisson with logpdf continuous in k. Essentially by replacing denominator with gamma function.\n\nwarning: Warning\nThe Distributions.logpdf has been redefined to be logpdf(d::RelaxedPoisson, x) =logpdf(d, x*d.λ). This is to reproduce the Poisson constraint term inpyhf`, which is a hack introduced for Asimov dataset.\n\n\n\n\n\n","category":"type"},{"location":"#LiteHF.Shapefactor","page":"LiteHF.jl","title":"LiteHF.Shapefactor","text":"Shapefactor is unconstrained, so interp is just identity. Unlike Normfactor, this is per-bin\n\n\n\n\n\n","category":"type"},{"location":"#LiteHF.Shapesys","page":"LiteHF.jl","title":"LiteHF.Shapesys","text":"Shapesys doesn't need interpolation, similar to Staterror\n\n\n\n\n\n","category":"type"},{"location":"#LiteHF.Staterror","page":"LiteHF.jl","title":"LiteHF.Staterror","text":"Staterror doesn't need interpolation, but it's a per-bin modifier. Information regarding which bin is the target is recorded in bintwoidentity.\n\nThe δ is the absolute yield uncertainty in each bin, and the relative uncertainty: δ / nominal is taken to be the σ of the prior, i.e. α ~ Normal(1, δ/nominal)\n\n\n\n\n\n","category":"type"},{"location":"#LiteHF._expkernel_unrolled_expansion_-Tuple{Any, Any, Any}","page":"LiteHF.jl","title":"LiteHF._expkernel_unrolled_expansion_","text":"_expkernel(modifiers, nominal, αs)\n\nThe Unrolled.@unroll kernel function that computs the expected counts.\n\n\n\n\n\n","category":"method"},{"location":"#LiteHF.build_channel-Tuple{Any}","page":"LiteHF.jl","title":"LiteHF.build_channel","text":"build_channel(rawjdict[:channels][1][:samples][2]) =>\nDict{String, ExpCounts}\n\n\n\n\n\n","category":"method"},{"location":"#LiteHF.build_modifier!-Tuple{Any, Any}","page":"LiteHF.jl","title":"LiteHF.build_modifier!","text":"build_modifier(rawjdict[:channels][1][:samples][2][:modifiers][1]) =>\n<:AbstractModifier\n\n\n\n\n\n","category":"method"},{"location":"#LiteHF.build_modifier-Union{Tuple{T}, Tuple{Any, Type{T}}} where T","page":"LiteHF.jl","title":"LiteHF.build_modifier","text":"build_modifier(...[:modifiers][1][:data], Type) =>\n<:AbstractModifier\n\n\n\n\n\n","category":"method"},{"location":"#LiteHF.build_pyhf-Tuple{Any}","page":"LiteHF.jl","title":"LiteHF.build_pyhf","text":"build_pyhf(load_pyhfjson(path)) -> PyHFModel\n\nthe expected(αs) is a function that takes vector or tuple of length N, where N is also the length of priors and priornames. In other words, these three fields of the returned object are aligned.\n\nnote: Note\nThe bins from different channels are automatically concatenated.\n\n\n\n\n\n","category":"method"},{"location":"#LiteHF.build_sample","page":"LiteHF.jl","title":"LiteHF.build_sample","text":"build_sample(rawjdict[:channels][1][:samples][2]) =>\nExpCounts\n\n\n\n\n\n","category":"function"},{"location":"#LiteHF.internal_expected-Tuple{Any, Any, Any}","page":"LiteHF.jl","title":"LiteHF.internal_expected","text":"internal_expected(Es, Vs, αs)\n\nThe @generated function that computes expected counts in PyHFModel.expected() evaluation. The Vs::NTuple{N, Vector{Int64}} has the same length as Es::NTuple{N, ExpCounts}.\n\nIn general αs is shorter than Es and Vs because a given nuisance parameter α may appear in multiple sample / modifier.\n\nnote: Note\nIf for example Vs[1] = [1,3,4], it means that the first ExpCount in Es is evaluated withEs[1](@view αs[[1,3,4]])and so on.\n\n\n\n\n\n","category":"method"},{"location":"#LiteHF.load_pyhfjson-Tuple{Any}","page":"LiteHF.jl","title":"LiteHF.load_pyhfjson","text":"load_pyhfjson(path)\n\n\n\n\n\n","category":"method"},{"location":"#LiteHF.pyhf_loglikelihoodof-Tuple{Any, Any, Any}","page":"LiteHF.jl","title":"LiteHF.pyhf_loglikelihoodof","text":"pyhf_loglikelihoodof(expected, obs, priors)\n\nReturn a callable Function that would calculate the log likelihood FlatPrior prior shouldn't have contribution to constraint\n\nnote: Note\nThe \"constraint\" terms that come from prior IS included here.\n\n\n\n\n\n","category":"method"},{"location":"#LiteHF.pyhf_loglikelihoodof-Tuple{Any, Any}","page":"LiteHF.jl","title":"LiteHF.pyhf_loglikelihoodof","text":"pyhf_loglikelihoodof(expected, obs)\n\nReturn a callable Function that would calculate the log likelihood\n\nnote: Note\nThe \"constraint\" terms that come from prior is NOT included here.\n\n\n\n\n\n","category":"method"},{"location":"#LiteHF.twoidentity-Tuple{Any, Any}","page":"LiteHF.jl","title":"LiteHF.twoidentity","text":"Identity function that takes two argument. Used for interpolation code that\ndoesn't do any interpolation.\n\n\n\n\n\n","category":"method"}]
}
