var documenterSearchIndex = {"docs":
[{"location":"#LiteHF.jl","page":"APIs","title":"LiteHF.jl","text":"","category":"section"},{"location":"","page":"APIs","title":"APIs","text":"Documentation for LiteHF.jl","category":"page"},{"location":"","page":"APIs","title":"APIs","text":"Modules = [LiteHF]\nOrder   = [:type, :function]","category":"page"},{"location":"#LiteHF.ExpCounts","page":"APIs","title":"LiteHF.ExpCounts","text":"struct ExpCounts{T, M} #M is a long Tuple for unrolling purpose.\n    nominal::T\n    modifier_names::Vector{Symbol}\n    modifiers::M\nend\n\nA callable struct that returns the expected count given modifier nuisance parameter values. The # of parameters passed must equal to length of modifiers. See _expkernel\n\n\n\n\n\n","category":"type"},{"location":"#LiteHF.FlatPrior","page":"APIs","title":"LiteHF.FlatPrior","text":"Pseudo flat prior in the sense that `logpdf()` always evaluates to zero,\nbut `rand()`, `minimum()`, and `maximum()` behaves like `Uniform(a, b)`.\n\n\n\n\n\n","category":"type"},{"location":"#LiteHF.Histosys","page":"APIs","title":"LiteHF.Histosys","text":"Histosys is defined by two vectors represending bin counts in hi_data and lo_data\n\n\n\n\n\n","category":"type"},{"location":"#LiteHF.InterpCode0","page":"APIs","title":"LiteHF.InterpCode0","text":"InterpCode0{T}\n\nCallable struct for interpolation for additive modifier. Code0 is the two-piece linear interpolation.\n\n\n\n\n\n","category":"type"},{"location":"#LiteHF.InterpCode1","page":"APIs","title":"LiteHF.InterpCode1","text":"InterpCode1{T}\n\nCallable struct for interpolation for multiplicative modifier. Code1 is the exponential interpolation.\n\n\n\n\n\n","category":"type"},{"location":"#LiteHF.InterpCode4","page":"APIs","title":"LiteHF.InterpCode4","text":"InterpCode4{T}\n\nCallable struct for interpolation for additive modifier. Code4 is the exponential + 6-order polynomial interpolation.\n\n\n\n\n\n","category":"type"},{"location":"#LiteHF.Lumi","page":"APIs","title":"LiteHF.Lumi","text":"Luminosity doesn't need interpolation, σ is provided at modifier construction time. In pyhf JSON, this  information lives in the \"Measurement\" section, usually near the end of the JSON file.\n\n\n\n\n\n","category":"type"},{"location":"#LiteHF.MultOneHot","page":"APIs","title":"LiteHF.MultOneHot","text":"MultOneHot{T} <: AbstractVector{T}\n\nInternal type used to avoid allocation for per-bin multiplicative systematics. It behaves as a vector with length nbins and  only has value α on nthbin-th index, the rest being one(T). See also binidentity.\n\n\n\n\n\n","category":"type"},{"location":"#LiteHF.Normfactor","page":"APIs","title":"LiteHF.Normfactor","text":"Normfactor is unconstrained, so interp is just identity.\n\n\n\n\n\n","category":"type"},{"location":"#LiteHF.Normsys-Tuple{Number, Number}","page":"APIs","title":"LiteHF.Normsys","text":"Normsys is defined by two multiplicative scalars\n\n\n\n\n\n","category":"method"},{"location":"#LiteHF.PyHFModel","page":"APIs","title":"LiteHF.PyHFModel","text":"struct PyHFModel{E, L}\n    expected::E\n    priors\n    prior_names\n    prior_inits::Vector{Float64}\n    LogLikelihood::L\nend\n\nStruct for holding result from build_pyhf.\n\n\n\n\n\n","category":"type"},{"location":"#LiteHF.RelaxedPoisson","page":"APIs","title":"LiteHF.RelaxedPoisson","text":"RelaxedPoisson\n\nPoisson with logpdf continuous in k. Essentially by replacing denominator with gamma function.\n\nwarning: Warning\nThe Distributions.logpdf has been redefined to be logpdf(d::RelaxedPoisson, x) = logpdf(d, x*d.λ). This is to reproduce the Poisson constraint term in pyhf, which is a hack introduced for Asimov dataset.\n\n\n\n\n\n","category":"type"},{"location":"#LiteHF.Shapefactor","page":"APIs","title":"LiteHF.Shapefactor","text":"Shapefactor is unconstrained, so interp is just identity. Unlike Normfactor, this is per-bin\n\n\n\n\n\n","category":"type"},{"location":"#LiteHF.Shapesys","page":"APIs","title":"LiteHF.Shapesys","text":"Shapesys doesn't need interpolation, similar to Staterror\n\n\n\n\n\n","category":"type"},{"location":"#LiteHF.Staterror","page":"APIs","title":"LiteHF.Staterror","text":"Staterror doesn't need interpolation, but it's a per-bin modifier. Information regarding which bin is the target is recorded in bintwoidentity.\n\nThe δ is the absolute yield uncertainty in each bin, and the relative uncertainty: δ / nominal is taken to be the σ of the prior, i.e. α ~ Normal(1, δ/nominal)\n\n\n\n\n\n","category":"type"},{"location":"#LiteHF._expkernel_unrolled_expansion_-Tuple{Any, Any, Any}","page":"APIs","title":"LiteHF._expkernel_unrolled_expansion_","text":"_expkernel(modifiers, nominal, αs)\n\nThe Unrolled.@unroll kernel function that computs the expected counts.\n\n\n\n\n\n","category":"method"},{"location":"#LiteHF.binidentity-Tuple{Any, Any}","page":"APIs","title":"LiteHF.binidentity","text":"binidentity(nbins, nthbin)\n\nA functional that used to track per-bin systematics. Returns the closure function over nbins, nthbin:\n\n    α -> MultOneHot(nbins, nthbin, α)\n\n\n\n\n\n","category":"method"},{"location":"#LiteHF.build_channel-Tuple{Any}","page":"APIs","title":"LiteHF.build_channel","text":"build_channel(rawjdict[:channels][1][:samples][2]) =>\nDict{String, ExpCounts}\n\n\n\n\n\n","category":"method"},{"location":"#LiteHF.build_modifier!-Tuple{Any, Any}","page":"APIs","title":"LiteHF.build_modifier!","text":"build_modifier(rawjdict[:channels][1][:samples][2][:modifiers][1]) =>\n<:AbstractModifier\n\n\n\n\n\n","category":"method"},{"location":"#LiteHF.build_modifier-Union{Tuple{T}, Tuple{Any, Type{T}}} where T","page":"APIs","title":"LiteHF.build_modifier","text":"build_modifier(...[:modifiers][1][:data], Type) =>\n<:AbstractModifier\n\n\n\n\n\n","category":"method"},{"location":"#LiteHF.build_pyhf-Tuple{Any}","page":"APIs","title":"LiteHF.build_pyhf","text":"build_pyhf(load_pyhfjson(path)) -> PyHFModel\n\nthe expected(αs) is a function that takes vector or tuple of length N, where N is also the length of priors and priornames. In other words, these three fields of the returned object are aligned.\n\nnote: Note\nThe bins from different channels are put into a NTuple{Nbins, Vector}.\n\n\n\n\n\n","category":"method"},{"location":"#LiteHF.build_sample","page":"APIs","title":"LiteHF.build_sample","text":"build_sample(rawjdict[:channels][1][:samples][2]) =>\nExpCounts\n\n\n\n\n\n","category":"function"},{"location":"#LiteHF.internal_expected-Tuple{Any, Any, Any}","page":"APIs","title":"LiteHF.internal_expected","text":"internal_expected(Es, Vs, αs)\n\nThe @generated function that computes expected counts in PyHFModel.expected() evaluation. The Vs::NTuple{N, Vector{Int64}} has the same length as Es::NTuple{N, ExpCounts}.\n\nIn general αs is shorter than Es and Vs because a given nuisance parameter α may appear in multiple sample / modifier.\n\nnote: Note\nIf for example Vs[1] = [1,3,4], it means that the first ExpCount in Es is evaluated withEs[1](@view αs[[1,3,4]])and so on.\n\n\n\n\n\n","category":"method"},{"location":"#LiteHF.load_pyhfjson-Tuple{Any}","page":"APIs","title":"LiteHF.load_pyhfjson","text":"load_pyhfjson(path)\n\n\n\n\n\n","category":"method"},{"location":"#LiteHF.pyhf_logjointof-Tuple{Any, Any, Any}","page":"APIs","title":"LiteHF.pyhf_logjointof","text":"pyhf_logjointof(expected, obs, priors)\n\nReturn a callable Function that would calculate the joint log likelihood of likelihood and priors.\n\nEquivalent of adding loglikelihood and logprior together.\n\nnote: Note\nThe \"constraint\" terms are included here.\n\n\n\n\n\n","category":"method"},{"location":"#LiteHF.pyhf_loglikelihoodof-Tuple{Any, Any}","page":"APIs","title":"LiteHF.pyhf_loglikelihoodof","text":"pyhf_loglikelihoodof(expected, obs)\n\nReturn a callable Function L(αs) that would calculate the log likelihood. expected is a callable of αs as well.\n\nnote: Note\nThe so called \"constraint\" terms (from priors) are NOT included here.\n\n\n\n\n\n","category":"method"},{"location":"#LiteHF.pyhf_logpriorof-Tuple{Any}","page":"APIs","title":"LiteHF.pyhf_logpriorof","text":"pyhf_logpriorof(priors)\n\nReturn a callable Function L(αs) that would calculate the log likelihood for the priors.\n\nnote: Note\nSometimes these are called the \"constraint\" terms.\n\n\n\n\n\n","category":"method"},{"location":"tips/","page":"Tips & Recommendations","title":"Tips & Recommendations","text":"function f(path)\n    pydict = load_pyhfjson(path)\n    pyhfmodel = build_pyhf(pydict)\n    pyhfmodel\nend\n\nR = f(\"./blah.json\")\n\nmaximize(\n        R.LogLikelihood, \n        R.prior_inits, \n        BFGS(), \n        Optim.Options(f_tol=1e-5, time_limit=10); \n        autodiff=:forward\n        );","category":"page"}]
}
